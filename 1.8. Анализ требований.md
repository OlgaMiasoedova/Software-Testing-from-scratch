# 1.8. Анализ требований

**Дополнительная информация:**

1. Тестирование программного обеспечения. Базовый курс. стр. 32  [https://svyatoslav.biz/software_testing_book/](https://svyatoslav.biz/software_testing_book/)
2. Библия QA. Требования (Requirements) [https://vladislaveremeev.gitbook.io/qa_bible/testovaya-dokumentaciya-i-artefakty-test-deliverablestest-artifacts/trebovaniya-requirements](https://vladislaveremeev.gitbook.io/qa_bible/testovaya-dokumentaciya-i-artefakty-test-deliverablestest-artifacts/trebovaniya-requirements)
3. Чек-лист тестирования требований [https://habr.com/ru/post/543340/](https://habr.com/ru/post/543340/)
4. Визуализация ТЗ — диаграммы, схемы, картинки [https://habr.com/ru/post/550498/](https://habr.com/ru/post/550498/)
<br>
<br>

## Содержание:
### [Источники и пути выявления требований](#text1)
### [Уровни и типы требований](#text2)
### [Неявные требования](#text3)
### [Свойства качественных требований](#text4)
### [Документирование требований](#text5)
### [Алгоритм работы с требованиями со стороны тестировщика](#text6)
### [Вопросы к теме](#task1)
<br>
<br>
<br>
<br>

<a id='text1'></a>
## **Источники и пути выявления требований**
<br>

**Требование (requirement)** -  условие, которое включает обязательные для выполнения критерии _[ISTQB Glossary]_

Перед тем как к команде разработки попадают финальные требования их необходимо собрать у заказчика. Для этого используют ряд техник на рисунке ниже.

Чаще всего этим занимаются бизнес-аналитики или владельцы продукта, поэтому в курсе мы не будем акцентировать на этом пристальное внимание.
<br>

<image src="/img/1.11. pic1.png" alt="">
<br>
<br>

Подробнее о них можно почитать [здесь](https://svyatoslav.biz/software_testing_book/)
<br>
<br>
<br>
<br>

<a id='text2'></a>
## **Уровни и типы требований**
<br>

Давайте сначала ознакомимся с этой "страшной" схемой, а затем поговорим только про самые важные ее части.
<br>

<image src="/img/1.11. pic2.png" alt="">
<br>
<br>

**Бизнес-требования (business requirements)** выражают цель, ради которой разрабатывается продукт (зачем вообще он нужен, какая от него ожидается польза, как заказчик с его помощью будет получать прибыль). 

Примеры:

- Нужен инструмент, в реальном времени отображающий наиболее выгодный курс покупки и продажи валюты;
    

- Необходимо в два-три раза повысить количество заявок, обрабатываемых одним оператором за смену;
    

- Нужно автоматизировать процесс выписки товарно-транспортных накладных на основе договоров.
    

**Пользовательские требования** (user requirements) описывают задачи, которые пользователь может выполнять с помощью разрабатываемой системы (реакцию системы на действия пользователя, сценарии работы пользователя). 

Пользовательские требования оформляются в виде вариантов использования (use cases), пользовательских историй (user stories), пользовательских сценариев (user scenarios). Часть из них мы рассмотрим далее в уроке.

Примеры:

- При первом входе пользователя в систему должно отображаться лицензионное соглашение;
    

- Администратор должен иметь возможность просматривать список всех пользователей, работающих в данный момент в системе;
    

- При первом сохранении новой статьи система должна выдавать запрос на сохранение в виде черновика или публикацию.
    

**Функциональные требования** (functional requirements) описывают поведение системы, т.е. ее действия (вычисления, преобразования, проверки, обработку и т.д.). 

Примеры:

- В процессе инсталляции приложение должно проверять остаток свободного места на целевом носителе;
    

- Система должна автоматически выполнять резервное копирование данных ежедневно в указанный момент времени;
    

- Электронный адрес пользователя, вводимый при регистрации, должен быть проверен на соответствие требованиям RFC822.
    

**Нефункциональные требования** (non-functional requirements) описывают свойства системы (удобство использования, безопасность, надежность, расширяемость и т.д.), которыми она должна обладать при реализации своего поведения. 

Примеры:

- При одновременной непрерывной работе с системой 1000 пользователей, минимальное время между возникновением сбоев должно быть более или равно 100 часов;
    

- Ни при каких условиях общий объем используемой приложением памяти не может превышать 2 ГБ;
    

- Размер шрифта для любой надписи на экране должен поддерживать настройку в диапазоне от 5 до 15 пунктов.
    

**Спецификация требований** (software requirements specification, SRS84) объединяет в себе описание всех требований уровня продукта и может представлять собой весьма объёмный документ (сотни и тысячи страниц).

С остальными уровнями и типами требований вы можете ознакомиться [здесь](https://svyatoslav.biz/software_testing_book/), однако приоритет при обучении и подготовке к интервью советую сделать на уровни выше.
<br>
<br>
<br>
<br>

<a id='text3'></a>
## **Неявные требования**
<br>

Не всегда требования будут описаны на проекте в виде спецификации или пользовательской истории. В таком случае необходимо изучать неявные требования из других источников:

1. Законы, регламенты, инструкции
2. Список задач, существующие тесты и баг-репорты
3. Руководство пользователя
4. Реклама продукта
5. Интервью с командой и заказчиками
6. Чаты и email-переписка
7. Прототип, дизайн-макет
8. Конкурентный анализ, личный опыт

Это далеко не весь перечень, подробнее [здесь](https://software-testing.ru/library/around-testing/requirements/3567-requirements)
<br>
<br>
<br>
<br>

<a id='text4'></a>
## **Свойства качественных требований**
<br>

**Завершенность (completeness)**

Требование является полным и законченным с точки зрения представления в нём всей необходимой информации, ничто не пропущено по соображениям «это и так всем понятно».

_Примеры:_

1. Пароли должны храниться в зашифрованном виде
2. Экспорт осуществляется в форматы PDF, PNG и т.д.
3. Приведённые ссылки неоднозначны (например: «см. выше» вместо «см. раздел 123.45.b»)
<br>

**Атомарность, единичность (atomicity)**

Требование является атомарным, если его нельзя разбить на отдельные требования без потери завершённости и оно описывает одну и только одну ситуацию.

_Примеры:_

1. Кнопка “Restart” не должна отображаться при остановленном сервисе, окно “Log” должно вмещать не менее 20-ти записей о последних действиях пользователя
2. Если пользователь подтверждает заказ и редактирует заказ или откладывает заказ, должен выдаваться запрос на оплату
3. Когда пользователь входит в систему, ему должно отображаться приветствие; когда пользователь вошёл в систему, должно отображаться имя пользователя; когда пользователь выходит из системы, должно отображаться прощание
<br>

**Непротиворечивость, последовательность (consistency)**

Требование не должно содержать внутренних противоречий и противоречий другим требованиям и документам.

_Примеры:_ 

1. После успешного входа в систему пользователя, не имеющего права входить в систему...
2. “712.a Кнопка “Close” всегда должна быть красной” и “36452.x Кнопка “Close” всегда должна быть синей” - противоречия в разных требованиях
3. “В случае, если разрешение окна составляет менее 800x600…” — разрешение есть у экрана, у окна есть размер  
<br>     

**Недвусмысленность (unambiguousness, clearness)**

Требование должно быть описано без использования жаргона, неочевидных аббревиатур и расплывчатых формулировок, должно допускать только однозначное объективное понимание и быть атомарным в плане невозможности различной трактовки сочетания отдельных фраз.

_Примеры:_

1. «Доступ к ФС осуществляется посредством системы прозрачного шифрования» и «ФС предоставляет возможность фиксировать сообщения в их текущем состоянии с хранением истории всех изменений» - что такое ФС?
2. «Система конвертирует входной файл из формата PDF в выходной файл формата PNG» - некоторые вещи опущены, так как автор считает их очевидными
<br>

**Выполнимость (feasibility)**

Требование должно быть технологически выполнимым и реализуемым в рамках бюджета и сроков разработки проекта.

_Примеры:_

1. Анализ договоров должен выполняться с применением искусственного интеллекта, который будет выносить однозначное корректное заключение о степени выгоды от заключения договора - технически невыполнимо на данный момент
2. Система поиска должна заранее предусматривать все возможные варианты поисковых запросов и кэшировать их результаты - нельзя реализовать
3. «озолочение» (gold plating) — требования, которые крайне долго и/или дорого реализуются и при этом практически бесполезны для конечных пользователей
<br>

**Обязательность, нужность (obligatoriness) и актуальность (up-to-date).**

Если требование необязательное, оно должно быть просто исключено из набора требований. Если требование нужное, но «не очень важное», для указания этого факта используется указание приоритета. Также исключены (или переработаны) должны быть неактуальные требования

_Примеры:_

1. Требование было добавлено «на всякий случай», хотя реальной потребности в нём не было и нет.
2. Требованию выставлены неверные значения приоритета по критериям важности и/или срочности.
3. Требование устарело, но не было переработано или удалено.
<br>

**Прослеживаемость (traceability)**

Вертикальная позволяет соотносить между собой требования на различных уровнях требований, горизонтальная позволяет соотносить требование с тест-планом, тест-кейсами, архитектурными решениями и т.д.

_Примеры:_

1. Требования не пронумерованы, не структурированы, не имеют оглавления, не имеют работающих перекрёстных ссылок.
2. При разработке требований не были использованы инструменты и техники управления требованиями.
3. Набор требований неполный, носит обрывочный характер с явными «пробелами».
<br>

**Модифицируемость (modifiability)**

Это свойство характеризует простоту внесения изменений в отдельные требования и в набор требований.

_Примеры:_

1. Требования неатомарны и непрослеживаемы, а потому их изменение с высокой вероятностью порождает противоречивость.
2. Требования изначально противоречивы. В такой ситуации внесение изменений (не связанных с устранением противоречивости) только усугубляет ситуацию, увеличивая противоречивость и снижая прослеживаемость.
3. Требования представлены в неудобной для обработки форме (например, не использованы инструменты управления требованиями, и в итоге команде приходится работать с десятками огромных текстовых документов).
<br>

**Проранжированность по важности, стабильности, срочности (ranked for importance, stability, priority)**

Важность характеризует зависимость успеха проекта от успеха реализации требования. Стабильность характеризует вероятность того, что в обозримом будущем в требование не будет внесено никаких изменений.  
Срочность определяет распределение во времени усилий проектной команды по реализации того или иного требования.
<br>

**Корректность (correctness) и проверяемость (verifiability)**

Эти свойства вытекают из соблюдения всех вышеперечисленных. В дополнение можно отметить, что проверяемость подразумевает возможность создания объективного тест-кейса (тест-кейсов), однозначно показывающего, что требование реализовано верно и поведение приложения в точности соответствует требованию.
<br>

_**Источник: Святослав Куликов “Тестирование ПО. Базовый курс.”**_
<br>
<br>
<br>
<br>

<a id='text5'></a>
## **Документирование требований**
<br>

1. **Варианты использования (use cases)** представляют собой сценарии взаимодействия пользователя (или пользователей) с программным продуктом для достижения конкретной цели.

Человечками на схеме обозначаются акторы (не опечатка), которые используют систему. Прямоугольником обозначается система, а сам вариант использования (функция) овалом. Это так называемая use case диаграмма. 

Подробнее можно прочитать [_здесь_](https://testengineer.ru/chto-takoe-use-case/)
<br>

<image src="/img/1.11. pic3.png" alt="">
<br>
<br>

2. **Пользовательская история (user story)** - общее описание функций программы, написанное как бы от имени пользователя. На современных проектах чаще используют именно ее для документирования требований. 

User story создается по шаблону:

_“As a [persona], I [want to], [so that].”_

_«Как [тип клиента], [хочу то-то], [чтобы делать что-то]»._

_Упрощенные примеры:_

- Как Макс, я хочу пригласить друзей, чтобы мы вместе могли пользоваться этим замечательным сервисом.
- Как Саша, я хочу организовать свою работу, чтобы лучше контролировать ситуацию. 
- Как менеджер, я хочу видеть, как продвигается работа у моих коллег, чтобы можно было составлять более точные отчеты о наших успехах и неудачах.

Помимо описания самой user story в ней обязательно содержатся критерии готовности (acceptance criteria), в которых и будут отражены конкретные требования к разрабатываемой функции.

Подробнее можно прочитать [здесь](https://www.atlassian.com/ru/agile/project-management/user-stories) и [здесь](https://testengineer.ru/chto-takoe-user-story-i-kak-ee-pisat/).

3. **Mockup (макет)** - реалистичная модель нашего приложения, которая помогает показать, как дизайн будет выглядеть на frontend.

В тестировании макеты используются для проверки frontend и именно согласно им мы проверяем наличие определенных элементов, их размер, стиль, поведение.

[Пример mockup](https://www.figma.com/file/oEF8YOLK20cYwkcIcngDSg/Mockup-UI-Templates-(Community)?type=design&node-id=0-1&mode=design&t=Je1x3Rgqj4QlIa1K-0)
<br>
<br>
<br>
<br>

<a id='text6'></a>
## **Алгоритм работы с требованиями со стороны тестировщика**
<br>

**Идеальный процесс**

1. Требования создают бизнес-аналитики или владельцы продукта. Обычно они содержат в себе дизайнерские макеты.
2. Требования попадают к тестировщику, который проверяет их на соответствие свойствам качественных требований. Дополнительно в Scrum есть Backlog Refinement, где требования обсуждаются и уточняются командой на отдельном собрании.
3. В случае обнаружения неточностей, требования отправляются бизнес-аналитику на доработку, например, оставляется комментарий в системе.
4. Пункты 2-3 повторяются до тех пор, пока не будут устранены несоответствия. Параллельно требования могут изучать другие участники команды: разработчики, дизайнеры
5. После того как требования согласованы, они берутся в разработку, а тестировщики создают тестовую документацию для дальнейших проверок. Важно: тест-кейсы и чек-листы создаются до того, как функциональность из требования будет разработана. Вспоминаем Shift Left Testing и раннее тестирование. 
6. Вносить изменения в требования после начала спринта не рекомендуется и по-хорошему должно быть запрещено.

**Неидеальный процесс**

1. Анализ требований не всегда осуществляется до этапа разработки, и уточнения могут вноситься уже во время нее 
2. Тестовая документация может создаваться уже после разработки функциональности
3. Требования могут вообще не документироваться и быть на проекте в неявном виде
<br>
<br>
<br>
<br>

<a id='task1'></a>
## Вопросы к теме
<br>

#### Соотнесите уровень требований и его характеристику
<br>

<image src="/img/1.11. pic4.png" alt="">
<br>
<br>

#### Верно ли утверждение?

> **Функциональные требования** описывают свойства системы (удобство использования, безопасность, надежность, расширяемость и т.д.), которыми она должна обладать при реализации своего поведения.
<br>

 -  [ ] Да
 -  [x] Нет
<br>
<br>

#### Соотнесите требование и свойство, которое оно нарушает
<br>

<image src="/img/1.11. pic5.png" alt="">
<br>
<br>

#### Верно ли утверждение?

> **Use case** - реалистичная модель нашего приложения, которая помогает показать, как дизайн будет выглядеть на frontend.
<br>

 -  [ ] Да
 -  [x] Нет
<br>
<br>

#### Верно ли утверждение?

>  **Модифицируемость** - это свойство характеризует простоту внесения изменений в отдельные требования и в набор требований.
<br>

 -  [x] Да
 -  [ ] Нет
<br>
<br>

#### Выберите правильно составленную User-story из списка
<br>

 -  [ ] Для организации своей работы мне необходимо отдельное приложение, которое бы соответствовало бизнес-требованиям
 -  [x] Как Саша, я хочу организовать свою собственную работу, чтобы чувствовать себя лучше
 -  [ ] Я хочу, чтобы приложение работало
 -  [ ] Саша хочет, чтобы приложение работало согласно его требованиям

